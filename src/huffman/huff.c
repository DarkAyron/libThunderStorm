/*****************************************************************************/
/* huffman.cpp                       Copyright (c) Ladislav Zezula 1998-2003 */
/*---------------------------------------------------------------------------*/
/* This module contains Huffmann (de)compression methods                     */
/*                                                                           */
/* Authors : Ladislav Zezula (ladik@zezula.net)                              */
/*           ShadowFlare     (BlakFlare@hotmail.com)                         */
/*           Ayron           (ayron@Shadowdrake.fur)                         */
/*                                                                           */
/*---------------------------------------------------------------------------*/
/*   Date    Ver   Who  Comment                                              */
/* --------  ----  ---  -------                                              */
/* xx.xx.xx  1.00  Lad  The first version of dcmp.cpp                        */
/* 03.05.03  1.00  Lad  Added compression methods                            */
/* 19.11.03  1.01  Dan  Big endian handling                                  */
/* 08.12.03  2.01  Dan  High-memory handling (> 0x80000000)                  */
/* 09.01.13  3.00  Lad  Refactored, beautified, documented :-)               */
/* 05.03.15  1.00  Ayr  Ported to plain C                                    */
/*****************************************************************************/
 
#include <assert.h>
#include <string.h>
 
#include "huff.h"

/* A virtual tree item that represents the head of the item list */
#define LIST_HEAD()  ((THTreeItem_t *)(&(huffTree->pFirst)))

/*-----------------------------------------------------------------------------
 * Table of byte-to-weight values
 */

/* Table for (de)compression. Every compression type has 258 entries */
static unsigned char ByteToWeight_00[] =
{
    0x0A, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02,
    0x00, 0x00
};

/* Data for compression type 0x01 */
static unsigned char ByteToWeight_01[] =
{
    0x54, 0x16, 0x16, 0x0D, 0x0C, 0x08, 0x06, 0x05, 0x06, 0x05, 0x06, 0x03, 0x04, 0x04, 0x03, 0x05,
    0x0E, 0x0B, 0x14, 0x13, 0x13, 0x09, 0x0B, 0x06, 0x05, 0x04, 0x03, 0x02, 0x03, 0x02, 0x02, 0x02,
    0x0D, 0x07, 0x09, 0x06, 0x06, 0x04, 0x03, 0x02, 0x04, 0x03, 0x03, 0x03, 0x03, 0x03, 0x02, 0x02,
    0x09, 0x06, 0x04, 0x04, 0x04, 0x04, 0x03, 0x02, 0x03, 0x02, 0x02, 0x02, 0x02, 0x03, 0x02, 0x04,
    0x08, 0x03, 0x04, 0x07, 0x09, 0x05, 0x03, 0x03, 0x03, 0x03, 0x02, 0x02, 0x02, 0x03, 0x02, 0x02,
    0x03, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x01, 0x01, 0x01, 0x02, 0x01, 0x02, 0x02,
    0x06, 0x0A, 0x08, 0x08, 0x06, 0x07, 0x04, 0x03, 0x04, 0x04, 0x02, 0x02, 0x04, 0x02, 0x03, 0x03,
    0x04, 0x03, 0x07, 0x07, 0x09, 0x06, 0x04, 0x03, 0x03, 0x02, 0x01, 0x02, 0x02, 0x02, 0x02, 0x02,
    0x0A, 0x02, 0x02, 0x03, 0x02, 0x02, 0x01, 0x01, 0x02, 0x02, 0x02, 0x06, 0x03, 0x05, 0x02, 0x03,
    0x02, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x02, 0x03, 0x01, 0x01, 0x01,
    0x02, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x02, 0x04, 0x04, 0x04, 0x07, 0x09, 0x08, 0x0C, 0x02,
    0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x02, 0x01, 0x01, 0x03,
    0x04, 0x01, 0x02, 0x04, 0x05, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x02, 0x01, 0x01, 0x01,
    0x04, 0x01, 0x01, 0x01, 0x01, 0x01, 0x02, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,
    0x02, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x03, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,
    0x02, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x02, 0x02, 0x01, 0x01, 0x02, 0x02, 0x02, 0x06, 0x4B,
    0x00, 0x00
};
   
/* Data for compression type 0x02 */
static unsigned char ByteToWeight_02[] =
{
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x27, 0x00, 0x00, 0x23, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0xFF, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x02, 0x02, 0x01, 0x01, 0x06, 0x0E, 0x10, 0x04,
    0x06, 0x08, 0x05, 0x04, 0x04, 0x03, 0x03, 0x02, 0x02, 0x03, 0x03, 0x01, 0x01, 0x02, 0x01, 0x01,
    0x01, 0x04, 0x02, 0x04, 0x02, 0x02, 0x02, 0x01, 0x01, 0x04, 0x01, 0x01, 0x02, 0x03, 0x03, 0x02,
    0x03, 0x01, 0x03, 0x06, 0x04, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x02, 0x01, 0x02, 0x01, 0x01,
    0x01, 0x29, 0x07, 0x16, 0x12, 0x40, 0x0A, 0x0A, 0x11, 0x25, 0x01, 0x03, 0x17, 0x10, 0x26, 0x2A,
    0x10, 0x01, 0x23, 0x23, 0x2F, 0x10, 0x06, 0x07, 0x02, 0x09, 0x01, 0x01, 0x01, 0x01, 0x01, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00
};
   
/* Data for compression type 0x03 */
static unsigned char ByteToWeight_03[] =
{
    0xFF, 0x0B, 0x07, 0x05, 0x0B, 0x02, 0x02, 0x02, 0x06, 0x02, 0x02, 0x01, 0x04, 0x02, 0x01, 0x03,
    0x09, 0x01, 0x01, 0x01, 0x03, 0x04, 0x01, 0x01, 0x02, 0x01, 0x01, 0x01, 0x02, 0x01, 0x01, 0x01,
    0x05, 0x01, 0x01, 0x01, 0x0D, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,
    0x02, 0x01, 0x01, 0x03, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x02, 0x01, 0x01, 0x01, 0x01,
    0x0A, 0x04, 0x02, 0x01, 0x06, 0x03, 0x02, 0x01, 0x01, 0x01, 0x01, 0x01, 0x03, 0x01, 0x01, 0x01,
    0x05, 0x02, 0x03, 0x04, 0x03, 0x03, 0x03, 0x02, 0x01, 0x01, 0x01, 0x02, 0x01, 0x02, 0x03, 0x03,
    0x01, 0x03, 0x01, 0x01, 0x02, 0x05, 0x01, 0x01, 0x04, 0x03, 0x05, 0x01, 0x03, 0x01, 0x03, 0x03,
    0x02, 0x01, 0x04, 0x03, 0x0A, 0x06, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,
    0x02, 0x02, 0x01, 0x0A, 0x02, 0x05, 0x01, 0x01, 0x02, 0x07, 0x02, 0x17, 0x01, 0x05, 0x01, 0x01,
    0x0E, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,
    0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,
    0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,
    0x06, 0x02, 0x01, 0x04, 0x05, 0x01, 0x01, 0x02, 0x01, 0x01, 0x01, 0x01, 0x02, 0x01, 0x01, 0x01,
    0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,
    0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x07, 0x01, 0x01, 0x02, 0x01, 0x01, 0x01, 0x01,
    0x02, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x02, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x11,
    0x00, 0x00
};
   
/* Data for compression type 0x04 */
static unsigned char ByteToWeight_04[] =
{
    0xFF, 0xFB, 0x98, 0x9A, 0x84, 0x85, 0x63, 0x64, 0x3E, 0x3E, 0x22, 0x22, 0x13, 0x13, 0x18, 0x17,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00
};
   
/* Data for compression type 0x05 */
static unsigned char ByteToWeight_05[] =
{
    0xFF, 0xF1, 0x9D, 0x9E, 0x9A, 0x9B, 0x9A, 0x97, 0x93, 0x93, 0x8C, 0x8E, 0x86, 0x88, 0x80, 0x82,
    0x7C, 0x7C, 0x72, 0x73, 0x69, 0x6B, 0x5F, 0x60, 0x55, 0x56, 0x4A, 0x4B, 0x40, 0x41, 0x37, 0x37,
    0x2F, 0x2F, 0x27, 0x27, 0x21, 0x21, 0x1B, 0x1C, 0x17, 0x17, 0x13, 0x13, 0x10, 0x10, 0x0D, 0x0D,
    0x0B, 0x0B, 0x09, 0x09, 0x08, 0x08, 0x07, 0x07, 0x06, 0x05, 0x05, 0x04, 0x04, 0x04, 0x19, 0x18,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00
};
   
    /* Data for compression type 0x06 */
static unsigned char ByteToWeight_06[] =
{
    0xC3, 0xCB, 0xF5, 0x41, 0xFF, 0x7B, 0xF7, 0x21, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0xBF, 0xCC, 0xF2, 0x40, 0xFD, 0x7C, 0xF7, 0x22, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x7A, 0x46, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00
};
   
/* Data for compression type 0x07 */
static unsigned char ByteToWeight_07[] =
{
    0xC3, 0xD9, 0xEF, 0x3D, 0xF9, 0x7C, 0xE9, 0x1E, 0xFD, 0xAB, 0xF1, 0x2C, 0xFC, 0x5B, 0xFE, 0x17,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0xBD, 0xD9, 0xEC, 0x3D, 0xF5, 0x7D, 0xE8, 0x1D, 0xFB, 0xAE, 0xF0, 0x2C, 0xFB, 0x5C, 0xFF, 0x18,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x70, 0x6C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00
};
   
/* Data for compression type 0x08 */
static unsigned char ByteToWeight_08[] =
{
    0xBA, 0xC5, 0xDA, 0x33, 0xE3, 0x6D, 0xD8, 0x18, 0xE5, 0x94, 0xDA, 0x23, 0xDF, 0x4A, 0xD1, 0x10,
    0xEE, 0xAF, 0xE4, 0x2C, 0xEA, 0x5A, 0xDE, 0x15, 0xF4, 0x87, 0xE9, 0x21, 0xF6, 0x43, 0xFC, 0x12,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0xB0, 0xC7, 0xD8, 0x33, 0xE3, 0x6B, 0xD6, 0x18, 0xE7, 0x95, 0xD8, 0x23, 0xDB, 0x49, 0xD0, 0x11,
    0xE9, 0xB2, 0xE2, 0x2B, 0xE8, 0x5C, 0xDD, 0x15, 0xF1, 0x87, 0xE7, 0x20, 0xF7, 0x44, 0xFF, 0x13,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x5F, 0x9E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00
};

static unsigned char * WeightTables[0x09] =
{
    ByteToWeight_00,
    ByteToWeight_01,
    ByteToWeight_02,
    ByteToWeight_03,
    ByteToWeight_04,
    ByteToWeight_05,
    ByteToWeight_06,
    ByteToWeight_07,
    ByteToWeight_08
};

/*----------------------------------------------------------------------------- 
 * Debug/diagnostics
 */

#ifdef _DEBUG
void DumpHuffmannTree(THTreeItem_t * pItem)
{
    THTreeItem_t * pChildLo;                          /* Item with the lower weight */
    THTreeItem_t * pChildHi;                          /* Item with the higher weight */

    /* Get the lower-weight branch */
    pChildLo = pItem->pChildLo;
    if(pChildLo != NULL)
    {
        /* Get the higher-weight branch */
        pChildHi = pChildLo->pPrev;

        /* Parse the lower-weight branch */
        DumpHuffmannTree(pChildHi);
        DumpHuffmannTree(pChildLo);
    }
}
#endif

/*-----------------------------------------------------------------------------
 * TInputStream functions
 */

void huff_TInputStreamInitialise(huff_Buffer * huffBuffer, void * pvInBuffer, size_t cbInBuffer)
{
    huffBuffer->pbBufferEnd = (unsigned char *)pvInBuffer + cbInBuffer;
    huffBuffer->pbBuffer = (unsigned char *)pvInBuffer;
    huffBuffer->BitBuffer = 0;
    huffBuffer->BitCount = 0;
}

/* Gets 7 bits from the stream. DOES NOT remove the bits from input stream */
static unsigned int Peek7Bits(huff_Buffer * huffBuffer)
{
    unsigned int dwReloadByte = 0;

    /* If there is not enough bits to get the value, */
    /* we have to add 8 more bits from the input buffer */
    if(huffBuffer->BitCount < 7)
    {
        dwReloadByte = *(huffBuffer->pbBuffer)++;
        huffBuffer->BitBuffer |= dwReloadByte << huffBuffer->BitCount;
        huffBuffer->BitCount += 8;
    }

    /* Return the first available 7 bits. DO NOT remove them from the input stream */
    return (huffBuffer->BitBuffer & 0x7F);
}

/* Gets one bit from input stream */
static unsigned int Get1Bit(huff_Buffer * huffBuffer)
{
    unsigned int OneBit = 0;

    /* Ensure that the input stream is reloaded, if there are no bits left */
    if(huffBuffer->BitCount == 0)
    {
        /* Refill the bit buffer */
        huffBuffer->BitBuffer = *(huffBuffer->pbBuffer)++;
        huffBuffer->BitCount = 8;
    }

    /* Copy the bit from bit buffer to the variable */
    OneBit = (huffBuffer->BitBuffer & 0x01);
    huffBuffer->BitBuffer >>= 1;
    huffBuffer->BitCount--;

    return OneBit;
}   

/* Gets the whole byte from the input stream. */
static unsigned int Get8Bits(huff_Buffer * huffBuffer)
{
    unsigned int dwReloadByte = 0;
    unsigned int dwOneByte = 0;

    /* If there is not enough bits to get the value, */
    /* we have to add 8 more bits from the input buffer */
    if(huffBuffer->BitCount < 8)
    {
        dwReloadByte = *(huffBuffer->pbBuffer)++;
        huffBuffer->BitBuffer |= dwReloadByte << huffBuffer->BitCount;
        huffBuffer->BitCount += 8;
    }

    /* Return the lowest 8 its */
    dwOneByte = (huffBuffer->BitBuffer & 0xFF);
    huffBuffer->BitBuffer >>= 8;
    huffBuffer->BitCount -= 8;
    return dwOneByte;
}

static void SkipBits(huff_Buffer * huffBuffer, unsigned int dwBitsToSkip)
{
    unsigned int dwReloadByte = 0;

    /* If there is not enough bits in the buffer, */
    /* we have to add 8 more bits from the input buffer */
    if(huffBuffer->BitCount < dwBitsToSkip)
    {
        dwReloadByte = *(huffBuffer->pbBuffer)++;
        huffBuffer->BitBuffer |= dwReloadByte << huffBuffer->BitCount;
        huffBuffer->BitCount += 8;
    }

    /* Skip the remaining bits */
    huffBuffer->BitBuffer >>= dwBitsToSkip;
    huffBuffer->BitCount -= dwBitsToSkip;
}

/*-----------------------------------------------------------------------------
 * TOutputStream functions
 */

void huff_TOutputStreamInitialise(huff_Buffer * huffBuffer, void * pvOutBuffer, size_t cbOutLength)
{
    huffBuffer->pbBufferEnd = (unsigned char *)pvOutBuffer + cbOutLength;
    huffBuffer->pbBuffer = (unsigned char *)pvOutBuffer;
    huffBuffer->BitBuffer = 0;
    huffBuffer->BitCount = 0;
}

static void PutBits(huff_Buffer * huffBuffer, unsigned int dwValue, unsigned int nBitCount)
{
    huffBuffer->BitBuffer |= (dwValue << huffBuffer->BitCount);
    huffBuffer->BitCount += nBitCount;
 
    /* Flush completed bytes */
    while(huffBuffer->BitCount >= 8)
    {
        if(huffBuffer->pbBuffer < huffBuffer->pbBufferEnd)
            *(huffBuffer->pbBuffer)++ = (unsigned char)(huffBuffer->BitBuffer);
 
        huffBuffer->BitBuffer >>= 8;
        huffBuffer->BitCount -= 8;
    }
}

static void Flush(huff_Buffer * huffBuffer)
{
    while(huffBuffer->BitCount != 0)
    {
        if(huffBuffer->pbBuffer < huffBuffer->pbBufferEnd)
            *(huffBuffer->pbBuffer)++ = (unsigned char)(huffBuffer->BitBuffer);

        huffBuffer->BitBuffer >>= 8;
        huffBuffer->BitCount -= ((huffBuffer->BitCount > 8) ? 8 : huffBuffer->BitCount);
    }
}

/*-----------------------------------------------------------------------------
 * Methods of the THTreeItem struct
 */

static void RemoveItem(THTreeItem_t * treeItem)
{
    if(treeItem->pNext != NULL)
    {
        treeItem->pPrev->pNext = treeItem->pNext;
        treeItem->pNext->pPrev = treeItem->pPrev;
        treeItem->pNext = treeItem->pPrev = NULL;
    }
}

/*-----------------------------------------------------------------------------
 * THuffmannTree class functions
 */

void huffTree_init(THuffmannTree * huffTree, int bCompression)
{
    huffTree->pFirst = huffTree->pLast = LIST_HEAD();
    huffTree->MinValidValue = 1;
    huffTree->ItemsUsed = 0;
 
    /* If we are going to decompress data, we need to invalidate all item links */
    /* We do so by zeroing their ValidValue, so it becomes lower MinValidValue */
    if(!bCompression)
    {
        memset(huffTree->QuickLinks, 0, sizeof(huffTree->QuickLinks));
    }
}

static void LinkTwoItems(THTreeItem_t * pItem1, THTreeItem_t * pItem2)
{
    pItem2->pNext = pItem1->pNext;
    pItem2->pPrev = pItem1->pNext->pPrev;
    pItem1->pNext->pPrev = pItem2;
    pItem1->pNext = pItem2;
}

/* Inserts item into the tree (?) */
static void InsertItem(THuffmannTree * huffTree, THTreeItem_t * pNewItem, int InsertPoint, THTreeItem_t * pInsertPoint)
{
    /* Remove the item from the tree */
    RemoveItem(pNewItem);
 
    if(pInsertPoint == NULL)
        pInsertPoint = LIST_HEAD();

    switch(InsertPoint)
    {
        case InsertAfter:
            LinkTwoItems(pInsertPoint, pNewItem);
            return;
       
        case InsertBefore:
            pNewItem->pNext = pInsertPoint;             /* Set next item (or pointer to pointer to first item) */
            pNewItem->pPrev = pInsertPoint->pPrev;      /* Set prev item (or last item in the tree) */
            pInsertPoint->pPrev->pNext = pNewItem;
            pInsertPoint->pPrev = pNewItem;             /* Set the next/last item */
            return;
    }
}

static THTreeItem_t * FindHigherOrEqualItem(THuffmannTree * huffTree, THTreeItem_t * pItem, unsigned int Weight)
{
    /* Parse all existing items */
    if(pItem != NULL)
    {
        while(pItem != LIST_HEAD())
        {
            if(pItem->Weight >= Weight)
                return pItem;

            pItem = pItem->pPrev;
        }
    }

    /* If not found, we just get the first item */
    return LIST_HEAD();
}

static THTreeItem_t * CreateNewItem(THuffmannTree * huffTree, unsigned int DecompressedValue, unsigned int Weight, int InsertPoint)
{
    THTreeItem_t * pNewItem;

    /* Allocate new item from the item pool */
    pNewItem = &(huffTree->ItemBuffer)[huffTree->ItemsUsed++];

    /* Insert this item to the top of the tree */
    InsertItem(huffTree, pNewItem, InsertPoint, NULL);

    /* Fill the rest of the item */
    pNewItem->DecompressedValue = DecompressedValue;
    pNewItem->Weight = Weight;
    pNewItem->pParent = NULL;
    pNewItem->pChildLo = NULL;
    return pNewItem;
}

static unsigned int FixupItemPosByWeight(THuffmannTree * huffTree, THTreeItem_t * pNewItem, unsigned int MaxWeight)
{
    THTreeItem_t * pHigherItem;

    if(pNewItem->Weight < MaxWeight)
    {
        /* Find an item that has higher weight than this one */
        pHigherItem = FindHigherOrEqualItem(huffTree, huffTree->pLast, pNewItem->Weight);

        /* Remove the item and put it to the new position */
        RemoveItem(pNewItem);
        LinkTwoItems(pHigherItem, pNewItem);
    }
    else
    {
        MaxWeight = pNewItem->Weight;
    }

    /* Return the (updated) maximum weight */
    return MaxWeight;
}

/* Builds Huffman tree. Called with the first 8 bits loaded from input stream */
static void BuildTree(THuffmannTree * huffTree, unsigned int CompressionType)
{
    THTreeItem_t * pNewItem;
    THTreeItem_t * pChildLo;
    THTreeItem_t * pChildHi;
    unsigned char * WeightTable;
    unsigned int MaxWeight;                     /* [ESP+10] - The greatest character found in table */
    unsigned int i;
 
    /* Clear all pointers in HTree item array */
    memset(huffTree->ItemsByByte, 0, sizeof(huffTree->ItemsByByte));
    MaxWeight = 0;
 
    /* Ensure that the compression type is in range */
    assert((CompressionType & 0x0F) <= 0x08);
    WeightTable  = WeightTables[CompressionType & 0x0F];
 
    /* Build the linear list of entries that is sorted by byte weight */
    for(i = 0; i < 0x100; i++)
    {
        /* Skip all the bytes which are zero. */
        if(WeightTable[i] != 0)
        {
            /* Create new tree item */
            huffTree->ItemsByByte[i] = pNewItem = CreateNewItem(huffTree, i, WeightTable[i], InsertAfter);

            /* We need to put the item to the right place in the list */
            MaxWeight = FixupItemPosByWeight(huffTree, pNewItem, MaxWeight);
        }
    }
 
    /* Insert termination entries at the end of the list */
    huffTree->ItemsByByte[0x100] = CreateNewItem(huffTree, 0x100, 1, InsertBefore);
    huffTree->ItemsByByte[0x101] = CreateNewItem(huffTree, 0x101, 1, InsertBefore);
 
    /* Now we need to build the tree. We start at the last entry */
    /* and go backwards to the first one */
    pChildLo = huffTree->pLast;

    /* Work as long as both children are valid */
    /* pChildHi is child with higher weight, pChildLo is the one with lower weight */
    while(pChildLo != LIST_HEAD())
    {
        /* Also get and verify the higher-weight child */
        pChildHi = pChildLo->pPrev;
        if(pChildHi == LIST_HEAD())
            break;

        /* Create new parent item for the children */
        pNewItem = CreateNewItem(huffTree, 0, pChildHi->Weight + pChildLo->Weight, InsertAfter);

        /* Link both child items to their new parent */
        pChildLo->pParent = pNewItem;
        pChildHi->pParent = pNewItem;
        pNewItem->pChildLo = pChildLo;

        /* Fixup the item's position by its weight */
        MaxWeight = FixupItemPosByWeight(huffTree, pNewItem, MaxWeight);

        /* Get the previous lower-weight child */
        pChildLo = pChildHi->pPrev;
    }

    /* Initialize the MinValidValue to 1, which invalidates all quick-link items */
    huffTree->MinValidValue = 1;
}

static void IncWeightsAndRebalance(THuffmannTree * huffTree, THTreeItem_t * pItem)
{
    THTreeItem_t * pHigherItem;           /* A previous item with greater or equal weight */
    THTreeItem_t * pChildHi;              /* The higher-weight child */
    THTreeItem_t * pChildLo;              /* The lower-weight child */
    THTreeItem_t * pParent;
 
    /* Climb up the tree and increment weight of each tree item */
    for(; pItem != NULL; pItem = pItem->pParent)
    {
        /* Increment the item's weight */
        pItem->Weight++;

        /* Find a previous item with equal or greater weight, which is not equal to this item */
        pHigherItem = FindHigherOrEqualItem(huffTree, pItem->pPrev, pItem->Weight);
        pChildHi = pHigherItem->pNext;

        /* If the item is not equal to the tree item, we need to rebalance the tree */
        if(pChildHi != pItem)
        {
            /* Move the previous item to the RIGHT from the given item */
            RemoveItem(pChildHi);
            LinkTwoItems(pItem, pChildHi);
            
            /* Move the given item AFTER the greater-weight tree item */
            RemoveItem(pItem);
            LinkTwoItems(pHigherItem, pItem);
     
            /* We need to maintain the tree so that pChildHi->Weight is >= pChildLo->Weight. */
            /* Rebalance the tree accordingly. */
            pChildLo = pChildHi->pParent->pChildLo;
            pParent = pItem->pParent;
            if(pParent->pChildLo == pItem)
                pParent->pChildLo = pChildHi;
            if(pChildLo == pChildHi)
                pChildHi->pParent->pChildLo = pItem;
            pParent = pItem->pParent;
            pItem->pParent = pChildHi->pParent;
            pChildHi->pParent = pParent;

            /* Increment the global valid value. This invalidates all quick-link items. */
            huffTree->MinValidValue++;
        }
    }
}

static void InsertNewBranchAndRebalance(THuffmannTree * huffTree, unsigned int Value1, unsigned int Value2)
{
    THTreeItem_t * pLastItem = huffTree->pLast;
    THTreeItem_t * pChildHi;
    THTreeItem_t * pChildLo;

    /* Create higher-weight child */
    pChildHi = CreateNewItem(huffTree, Value1, pLastItem->Weight, InsertBefore);
    pChildHi->pParent = pLastItem;
    huffTree->ItemsByByte[Value1] = pChildHi;

    /* Create lower-weight child */
    pChildLo = CreateNewItem(huffTree, Value2, 0, InsertBefore);
    pChildLo->pParent = pLastItem;
    pLastItem->pChildLo = pChildLo;
    huffTree->ItemsByByte[Value2] = pChildLo;

    IncWeightsAndRebalance(huffTree, pChildLo);
}

static void EncodeOneByte(huff_Buffer * os, THTreeItem_t * pItem)
{
    THTreeItem_t * pParent = pItem->pParent;
    unsigned int BitBuffer = 0;
    unsigned int BitCount = 0;

    /* Put 1's as long as there is parent */
    while(pParent != NULL)
    {
        /* Fill the bit buffer */
        BitBuffer = (BitBuffer << 1) | ((pParent->pChildLo != pItem) ? 1 : 0);
        BitCount++;

        /* Move to the parent */
        pItem = pParent;
        pParent = pParent->pParent;
    }

    /* Write the bits to the output stream */
    PutBits(os, BitBuffer, BitCount);
}

static unsigned int DecodeOneByte(THuffmannTree * huffTree, huff_Buffer * is)
{
    THTreeItem_t * pItemLink = NULL;
    THTreeItem_t * pItem;
    unsigned int ItemLinkIndex;
    unsigned int BitCount = 0;

    /* Check for the end of the input stream */
    if(is->pbBuffer >= is->pbBufferEnd && is->BitCount < 7)
        return 0x1FF;

    /* Get the eventual quick-link index */
    ItemLinkIndex = Peek7Bits(is);
    
    /* Is the quick-link item valid? */
    if(huffTree->QuickLinks[ItemLinkIndex].ValidValue > huffTree->MinValidValue)
    {
        /* If that item needs less than 7 bits, we can get decompressed value directly */
        if(huffTree->QuickLinks[ItemLinkIndex].ValidBits <= 7)
        {
            SkipBits(is, huffTree->QuickLinks[ItemLinkIndex].ValidBits);
            return huffTree->QuickLinks[ItemLinkIndex].DecompressedValue;
        }

        /* Otherwise we cannot get decompressed value directly */
        /* but we can skip 7 levels of tree parsing */
        pItem = huffTree->QuickLinks[ItemLinkIndex].pItem;
        SkipBits(is, 7);
    }
    else
    {
        /* Just a sanity check */
        if(huffTree->pFirst == LIST_HEAD())
            return 0x1FF;

        /* We don't have the quick-link item, we need to parse the tree from its root */
        pItem = huffTree->pFirst;
    }

    /* Step down the tree until we find a terminal item */
    while(pItem->pChildLo != NULL)
    {
        /* If the next bit in the compressed stream is set, we get the higher-weight */
        /* child. Otherwise, get the lower-weight child. */
        pItem = Get1Bit(is) ? pItem->pChildLo->pPrev : pItem->pChildLo;
        BitCount++;

        /* If the number of loaded bits reached 7, */
        /* remember the current item for storing into quick-link item array */
        if(BitCount == 7)
            pItemLink = pItem;
    }

    /* If we didn't get the item from the quick-link array, */
    /* set the entry in it */
    if(huffTree->QuickLinks[ItemLinkIndex].ValidValue < huffTree->MinValidValue)
    {
        /* If the current compressed byte was more than 7 bits, */
        /* set a quick-link item with pointer to tree item */
        if(BitCount > 7)
        {
            huffTree->QuickLinks[ItemLinkIndex].ValidValue = huffTree->MinValidValue;
            huffTree->QuickLinks[ItemLinkIndex].ValidBits = BitCount;
            huffTree->QuickLinks[ItemLinkIndex].pItem = pItemLink;
        }
        else
        {
            /* Limit the quick-decompress item to lower amount of bits */
            ItemLinkIndex &= (0xFFFFFFFF >> (32 - BitCount));
            while(ItemLinkIndex < LINK_ITEM_COUNT)
            {
                /* Fill the quick-decompress item */
                huffTree->QuickLinks[ItemLinkIndex].ValidValue = huffTree->MinValidValue;
                huffTree->QuickLinks[ItemLinkIndex].ValidBits  = BitCount;
                huffTree->QuickLinks[ItemLinkIndex].DecompressedValue = pItem->DecompressedValue;

                /* Increment the index */
                ItemLinkIndex += (1 << BitCount);
            }
        }
    }

    /* Return the decompressed value from the found item */
    return pItem->DecompressedValue;
}

unsigned int huff_Compress(THuffmannTree * huffTree, huff_Buffer * os, void * pvInBuffer, int cbInBuffer, int CompressionType)
{
    unsigned char * pbInBufferEnd = (unsigned char *)pvInBuffer + cbInBuffer;
    unsigned char * pbInBuffer = (unsigned char *)pvInBuffer;
    unsigned char * pbOutBuff = os->pbBuffer;
    unsigned char InputByte;
 
    BuildTree(huffTree, CompressionType);
    huffTree->bIsCmp0 = (CompressionType == 0);

    /* Store the compression type into output buffer */
    PutBits(os, CompressionType, 8);
 
    /* Process the entire input buffer */
    while(pbInBuffer < pbInBufferEnd)
    {
        /* Get the (next) byte from the input buffer */
        InputByte = *pbInBuffer++;

        /* Do we have an item for such input value? */
        if(huffTree->ItemsByByte[InputByte] == NULL)
        {
            /* Encode the relationship */
            EncodeOneByte(os, huffTree->ItemsByByte[0x101]);
 
            /* Store the loaded byte into output stream */
            PutBits(os, InputByte, 8);
 
            InsertNewBranchAndRebalance(huffTree, huffTree->pLast->DecompressedValue, InputByte);

            if(huffTree->bIsCmp0)
            {
                IncWeightsAndRebalance(huffTree, huffTree->ItemsByByte[InputByte]);
                continue;
            }
  
            IncWeightsAndRebalance(huffTree, huffTree->ItemsByByte[InputByte]);
        }
        else
        {
            EncodeOneByte(os, huffTree->ItemsByByte[InputByte]);
        }
 
        if(huffTree->bIsCmp0)
        {
            IncWeightsAndRebalance(huffTree, huffTree->ItemsByByte[InputByte]);
        }
    }
 
    /* Put the termination mark to the compressed stream */
    EncodeOneByte(os, huffTree->ItemsByByte[0x100]);
 
    /* Flush the remaining bits */
    Flush(os);
    return (unsigned int)(os->pbBuffer - pbOutBuff);
}
 
/* Decompression using Huffman tree (1500E450) */
unsigned int huff_Decompress(THuffmannTree * huffTree, void * pvOutBuffer, unsigned int cbOutLength, huff_Buffer * is)
{
    unsigned char * pbOutBufferEnd = (unsigned char *)pvOutBuffer + cbOutLength;
    unsigned char * pbOutBuffer = (unsigned char *)pvOutBuffer;
    unsigned int DecompressedValue = 0;
    unsigned int CompressionType = 0;
   
    /* Test the output length. Must not be NULL. */
    if(cbOutLength == 0)
        return 0;
 
    /* Get the compression type from the input stream */
    CompressionType = Get8Bits(is);
    huffTree->bIsCmp0 = (CompressionType == 0) ? 1 : 0;
 
    /* Build the Huffman tree */
    BuildTree(huffTree, CompressionType);    
 
    /* Process the entire input buffer until end of the stream */
    while((DecompressedValue = DecodeOneByte(huffTree, is)) != 0x100)
    {
        /* Did an error occur? */
        if(DecompressedValue == 0x1FF)          /* An error occurred */
            return 0;

        /* Huffman tree needs to be modified */
        if(DecompressedValue == 0x101)
        {
            /* The decompressed byte is stored in the next 8 bits */
            DecompressedValue = Get8Bits(is);

            InsertNewBranchAndRebalance(huffTree, huffTree->pLast->DecompressedValue, DecompressedValue);

            if(huffTree->bIsCmp0 == 0)
                IncWeightsAndRebalance(huffTree, huffTree->ItemsByByte[DecompressedValue]);
        }
 
        /* A byte successfully decoded - store it in the output stream */
        *pbOutBuffer++ = (unsigned char)DecompressedValue;
        if(pbOutBuffer >= pbOutBufferEnd)
            break;
 
        if(huffTree->bIsCmp0)
        {
            IncWeightsAndRebalance(huffTree, huffTree->ItemsByByte[DecompressedValue]);
        }
    }
 
    return (unsigned int)(pbOutBuffer - (unsigned char *)pvOutBuffer);
}

